(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{735:function(n,t,o){"use strict";o.r(t);var a=o(4),s=Object(a.a)({},(function(){var n=this,t=n.$createElement,o=n._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("h1",{attrs:{id:"_1-前言"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-前言"}},[n._v("#")]),n._v(" 1. 前言")]),n._v(" "),o("p",[n._v("对于JavaScript开发者来说，this "),o("a",{attrs:{href:"https://juejin.cn/post/7118703212047106055",target:"_blank",rel:"noopener noreferrer"}},[n._v("不熟悉的小伙伴点这里"),o("OutboundLink")],1),n._v(" 是一个让我们头疼的关键字。但当我们真的学会this这个机制之后，就觉得它是真的香。下面我就来介绍this"),o("strong",[n._v("显示绑定call()、apply()、bind()")]),n._v(" 三种方法吧。")]),n._v(" "),o("h1",{attrs:{id:"_2-call-方法"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-call-方法"}},[n._v("#")]),n._v(" 2. call() 方法")]),n._v(" "),o("p",[n._v("定义： 调用一个对象的方法，以另一个对象换当前对象，可将一个函数的对象上下文从初始的上下文改变为由"),o("code",[n._v("thisObj")]),n._v(" 指定的新对象。")]),n._v(" "),o("p",[n._v("语法： "),o("strong",[n._v("Function.call(thisObj, arg1, arg2, ....)")])]),n._v(" "),o("p",[n._v("说明:")]),n._v(" "),o("ul",[o("li",[n._v("如果没提供"),o("code",[n._v("thisObj")]),n._v("参数，则会指向全局"),o("code",[n._v("Window")]),n._v("。")]),n._v(" "),o("li",[o("code",[n._v("call")]),n._v("接受多个参数为"),o("code",[n._v("Function")]),n._v("的参数，调用后返回"),o("code",[n._v("Funtion")]),n._v("函数的执行结果。")])]),n._v(" "),o("p",[n._v("实现"),o("code",[n._v("call")]),n._v("关键因素：")]),n._v(" "),o("ul",[o("li",[n._v("使Funtion 函数的this指向thisObj。")]),n._v(" "),o("li",[n._v("将Funtion 函数执行，同时将后序参数作为funtion的参数，若有返回值则返回。")])]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("Function.prototype.my_call = function() {\n  if (typeof this !== 'function') { // 优化函数才可以调用`call`\n    throw new TypeError('error')\n  }\n  let obj = arguments[0]\n  const args = Array.prototype.slice.call(arguments, 1) // 第一个函数以外的参数\n  obj = obj || window  // 防止没传第一个参数\n  const fn = Symbol('fn') // 声明 唯一变量 fn\n  obj[fn] = this // 改变函数this指向（关键代码）\n  const result = obj[fn](...args)  // 调用函数（关键代码）\n  delete obj[fn] // 删除 obj 上的 fn 属性\n  return result  // 返回函数执行结果\n}\n")])])]),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("var name = 'zhangsan'\nvar obj = {\n  name: 'lisi',\n  fn: 123\n}\n//我们实现\nconst res = foo.my_call(obj, 1, 2) \nconsole.log(res); //  lisi 3 \n // 官方\nconst res1 = foo.call(obj, 1, 2) //  lisi 3 \nconsole.log(res1); //  lisi 3 \n")])])]),o("h1",{attrs:{id:"_3-apply-方法"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_3-apply-方法"}},[n._v("#")]),n._v(" 3. apply() 方法")]),n._v(" "),o("p",[n._v("定义： 与call方法相同，但apply第二个参数接受一个数组。")]),n._v(" "),o("p",[n._v("语法： "),o("strong",[n._v("Function.call(thisObj, [arg1, arg2, ...])")])]),n._v(" "),o("p",[n._v("说明:")]),n._v(" "),o("ul",[o("li",[n._v("如果没提供"),o("code",[n._v("thisObj")]),n._v("参数，则会指向全局"),o("code",[n._v("Window")]),n._v("。")]),n._v(" "),o("li",[o("code",[n._v("apply")]),n._v("第二个参数为数组，调用后返回"),o("code",[n._v("Funtion")]),n._v("函数的执行结果。")])]),n._v(" "),o("p",[n._v("实现"),o("code",[n._v("apply")]),n._v("关键因素：")]),n._v(" "),o("ul",[o("li",[n._v("使Funtion 函数的this指向thisObj。")]),n._v(" "),o("li",[n._v("将Funtion 函数执行，同时将第二个参数作为Funtion的参数，返回Function的执行结果。")])]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("Function.prototype.my_apply = function(obj, args) {\n  if (typeof this !== 'function') { // 优化函数才可以调用`apply`\n    throw new TypeError('error')\n  }\n  obj = obj || window  // 防止没传第一个参数\n  const fn = Symbol('fn') // 声明 唯一变量 fn\n  obj[fn] = this  // 改变函数this指向（关键代码）\n  const res = obj[fn](...args)  // 调用函数（关键代码）\n  delete obj[fn] // 删除 obj 上的 fn 属性\n  return res // 返回函数执行结果\n}\n")])])]),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("var name = 'zhangsan'\nvar obj = {\n  name: 'lisi',\n  fn: 123\n}\n//我们实现\nconst res = foo.my_apply(obj, [1, 2]) \nconsole.log(res); //  lisi 3 \n // 官方\nconst res1 = foo.aplly(obj, [1, 2]) //  lisi 3 \nconsole.log(res1)  //  lisi 3 \n")])])]),o("h1",{attrs:{id:"_4-bind-方法"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_4-bind-方法"}},[n._v("#")]),n._v(" 4. bind() 方法")]),n._v(" "),o("p",[n._v("定义： 与call方法相同, 可接受任意参数。")]),n._v(" "),o("p",[n._v("语法： "),o("strong",[n._v("Function.call(thisObj, arg1, arg2, ...)")])]),n._v(" "),o("p",[n._v("说明:")]),n._v(" "),o("ul",[o("li",[n._v("如果没提供"),o("code",[n._v("thisObj")]),n._v("参数，则会指向全局"),o("code",[n._v("Window")]),n._v("。")]),n._v(" "),o("li",[o("code",[n._v("bind")]),n._v("接受任意个参数，调用后返回一个新的绑定函数。")])]),n._v(" "),o("p",[n._v("实现"),o("code",[n._v("bind")]),n._v("关键因素：")]),n._v(" "),o("ul",[o("li",[n._v("使Funtion 函数的this指向thisObj。")]),n._v(" "),o("li",[n._v("将Funtion 函数执行，同时其他参数作为Funtion的参数, 返回一个新的绑定函数。")]),n._v(" "),o("li",[o("strong",[n._v("如果 new 了返回的新的绑定的函数，该函数的this需要指向Function函数而不是thisObj。")])])]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("Function.prototype.my_bind = function(obj) {\n  if (typeof this !== 'function') { // 优化函数才可以调用`bind`\n    throw new TypeError('error')\n  }\n  obj = obj || window  // 防止没传第一个参数\n  const args = Array.prototype.slice.call(arguments, 1)  // 第一个函数以外的参数\n  const _this = this \n  const pro = function() {}\n  if (this.prototype) {\n    pro.prototype = this.prototype\n  }\n  const bound = function () { // 声明一个bound函数\n    // 判断该函数是否被new\n    return _this.apply(  // 掉用 apply 方法改变 this指向\n      this instanceof pro ? this : obj, // 判断 bound 函数时候被 new 了  如果 new this 指向foo 反之，指向 obj\n      args.concat(Array.prototype.slice.call(arguments))\n    )\n  }\n  bound.prototype = new pro() //  bound 函数的原型继承到了foo的原型  (原型链继承)\n  return bound // 返回 bound 函数\n}\n")])])]),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("var name = 'zhangsan'\nvar obj = {\n  name: 'lisi',\n  fn: 123\n}\nfunction foo(a, b) {\n  console.log(this.name, a + b);\n  return a + b\n}\n// 自己实现\nconst bar = foo.my_bind(obj)\nconsole.log(bar());\n let bar1 = new bar(3, 4)\n console.log(bar1);\n// 官方\nconst bar2 = foo.bind(obj)\nconsole.log(bar2());\nlet bar3 = new bar(3, 4)\nconsole.log(bar3);\n")])])]),o("p",[o("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d17bba193f941138cfc1d4b16eb61be~tplv-k3u1fbpfcp-watermark.image?",alt:"图片.png"}})]),n._v(" "),o("h1",{attrs:{id:"_5-结语"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_5-结语"}},[n._v("#")]),n._v(" 5. 结语")]),n._v(" "),o("p",[o("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91c95b94453247eeb0f4f7f946083a33~tplv-k3u1fbpfcp-watermark.image?",alt:"图片.png"}}),n._v("\n在不同的开发环境下，我们灵活的运用这三种显示绑定方法，可以使"),o("strong",[n._v("我们的this永远不会丢失。")])])])}),[],!1,null,null,null);t.default=s.exports}}]);