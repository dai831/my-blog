(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{743:function(n,a,r){"use strict";r.r(a);var e=r(4),t=Object(e.a)({},(function(){var n=this,a=n.$createElement,r=n._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("h1",{attrs:{id:"_1-前言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-前言"}},[n._v("#")]),n._v(" 1. 前言")]),n._v(" "),r("p",[n._v("相信我们在刷算法时，都做过把多维数组变成一维数组， 我们有很多办法，例如递归、flat（）函数、正则。既然数组可以扁平化为一维数组，那如果我们想把对象扁平化该怎么做呢？那我们就来介绍几种方法去实现数组和对象的扁平化。")]),n._v(" "),r("h1",{attrs:{id:"_2-数组扁平化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-数组扁平化"}},[n._v("#")]),n._v(" 2. 数组扁平化")]),n._v(" "),r("p",[n._v("题目描述： 给定你一个多维数组，例如："),r("strong",[n._v("[ 1, 2, [3, 4, [5]], 6, {a: 7} ]")]),n._v("，让我们将多维数组变为一维数组。")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("[ 1, 2, [3, 4, [5]], 6, {a: 7} ] ---\x3e [ 1, 2, 3, 4, 5, 6, { a: 7 } \n")])])]),r("h2",{attrs:{id:"_2-1-flat-方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-flat-方法"}},[n._v("#")]),n._v(" 2.1 flat()方法")]),n._v(" "),r("p",[n._v("首先我们第一个想到的就ES10新增的"),r("code",[n._v("flat()")]),n._v("方法, 它可以帮助我们实现数组扁平化。实现如下：")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("const arr = [ 1, 2, [3, 4, [5]], 6, {a: 7} ]\n\nconst newArr = arr.flat(1) // [ 1, 2, 3, 4, [ 5 ], 6, { a: 7 } ]\nconsole.log(newArr);\nconst newArr1 = arr.flat(2) // [ 1, 2, 3, 4, 5, 6, { a: 7 } ]\nconsole.log(newArr1);\nconst newArr2 = arr.flat(3) // [ 1, 2, 3, 4, 5, 6, { a: 7 } ]\nconsole.log(newArr2);\n")])])]),r("p",[r("code",[n._v("flat()")]),n._v("方法，可以直接帮我们实数组的扁平化，而且"),r("code",[n._v("falt()")]),n._v("方法还接受一个参数供我们选择将数组变为我们想要的维数。")]),n._v(" "),r("h2",{attrs:{id:"_2-2-reduce-方法-递归"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-reduce-方法-递归"}},[n._v("#")]),n._v(" 2.2 reduce() 方法+递归")]),n._v(" "),r("p",[n._v("那如果没有"),r("code",[n._v("flat()")]),n._v("方法， 我们还有其他的方法实现了数组扁平化吗？这是，我们还有一种很容易想到的办法，那就是递归。那我们就是使用"),r("code",[n._v("reduce() 方法+递归")]),n._v("的方式实现吧。")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("const arr = [ 1, 2, [3, 4, [5]], 6, {a: 7} ]\nlet myFlat = (arr) => {\n  return arr.reduce((pre, next) => {\n    return pre.concat(Array.isArray(next) ? myFlat(next) : next);\n  },[])\n}\nlet newArr = myFlat(arr)  \nconsole.log(newArr); // [ 1, 2, 3, 4, 5, 6, { a: 7 } ]\n")])])]),r("p",[n._v("在"),r("code",[n._v("reduce() 方法+递归")]),n._v("方式里，我们需要想到的就是，当我们循环碰到是数组的话，我们就需要递归的执行，然后将我们递归的结果在拼接成一个新的以为数组。")]),n._v(" "),r("p",[r("strong",[n._v("小提示：如果不熟系这两种方法的小伙伴可以去看"),r("a",{attrs:{href:"https://juejin.cn/post/7174043835880701966",target:"_blank",rel:"noopener noreferrer"}},[n._v("# 数组各种好用API的手写"),r("OutboundLink")],1),n._v("文章。")])]),n._v(" "),r("h2",{attrs:{id:"_2-3-不使用递归"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-不使用递归"}},[n._v("#")]),n._v(" 2.3 不使用递归")]),n._v(" "),r("p",[n._v("那到这里，很多小伙伴就该问了，使用了递归的性能还是不够好，那有不使用递归的方法吗？那到这里，我就再来实现一个不使用递归的方法。")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("const arr = [1, 2, [3, 4, [5]], 6, { a: 7 }]\nlet myFlat1 = (arr, num=1) => {\n  let newArr = arr\n  let i = 0\n  while (arr.some(item => Array.isArray(item)) && i< num) {\n    newArr = [].concat(...newArr)\n    i++\n  }\n  return newArr\n}\n  \nlet newArr1 = myFlat1(arr, 2)  \nconsole.log(newArr1); // [ 1, 2, 3, 4, 5, 6, { a: 7 } ]\n")])])]),r("p",[n._v("我们自己利用了数组身上的"),r("code",[n._v("some()")]),n._v("方法，去将遍历数组每个元素，再将符合条件的元素结构出来进行拼接，我们也实现了数组的扁平化。")]),n._v(" "),r("p",[r("strong",[n._v("小提示：这里我们还可以想到了一个办法，那就是利用正则表达式，去除数组左右两边的数组再进行拼接，小伙伴可以自己去试试哦")])]),n._v(" "),r("h1",{attrs:{id:"_3-对象扁平化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-对象扁平化"}},[n._v("#")]),n._v(" 3. 对象扁平化")]),n._v(" "),r("p",[n._v("在介绍完数组的扁平化之后，我们就该到我们的对象扁平化了。那我们该如何实现对象的扁平化呢？")]),n._v(" "),r("p",[n._v("题目描述：")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("const obj = {\n    a: {\n      b: 1,\n      c: 2,\n      d: { e: 5 }\n    }\n    b: [1, 3, { a: 2, b: 3 }]\n    c: 3\n  } \n-----\x3e \n// {\n  //   a.b: 1,\n  //   a.c: 2,\n  //   a.d.e: 5\n  //   b[0]: 1,  \n  //   b[1]: 3,  \n  //   b[2].a: 2,  \n  //   b[2].b: 3,  \n  //   c: 3\n  // }\n")])])]),r("p",[n._v("在看数组扁平化之后，我们不难看出实现扁平化的核心原理，就是当我们在循环数组时碰到是数组，我们该怎么处理？我们做的是将数组里的值拿出来，再拼接起来。")]),n._v(" "),r("p",[n._v("那如果是对象的扁平化呢？对象的键该怎么处理呢？那我就先来实现一下吧。")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("const obj = {\n    a: {\n      b: 1,\n      c: 2,\n      d: { e: 5 }\n    },\n    b: [1, 3, { a: 2, b: 3 }],\n    c: 3\n  }\n  \n  function flatten(obj) {\n    let res = {}\n    function dfs(cur, prefix) { // prefix参数是为了拿到保留上一级的键\n      if (typeof cur === 'object' && cur !== null) { // 递归结束条件\n        if (Array.isArray(cur)) { // 拿到数组的拼接方式\n          cur.forEach((item, index) => {\n            dfs(item, `${prefix}[${index}]`)\n          });\n        } else {\n          for (let key in cur) { // 拿到对象的拼接方式\n            dfs(cur[key], `${prefix}${prefix ? '.' : ''}${key}`) // 将上一级的键与这一级的键进行拼接\n          }\n        }\n      } else {\n        res[prefix] = cur\n      }\n    }\n    // 第一次\n    dfs(obj, '')\n    return res\n  }\n  console.log(flatten(obj));\n  // {\n  //   'a.b': 1,\n  //   'a.c': 2,\n  //   'a.d.e': 5,\n  //   'b[0]': 1,\n  //   'b[1]': 3,\n  //   'b[2].a': 2,\n  //   'b[2].b': 3,\n  //   c: 3\n  // }\n")])])]),r("p",[n._v("在对象的扁平化中，需要拿到对象的键，将对象的键进行一个拼接，然后我们再给对象的键去赋值既实现了对象的扁平化。")]),n._v(" "),r("h1",{attrs:{id:"结语"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#结语"}},[n._v("#")]),n._v(" 结语")]),n._v(" "),r("p",[n._v("数组扁平化和对象的扁平化方式都遵循了一个道理，那就是我们循环拿到数组或对象时，我们都要将它们拼接处理成想要的模式，再返回出来。码字不易，点个赞吧。")])])}),[],!1,null,null,null);a.default=t.exports}}]);