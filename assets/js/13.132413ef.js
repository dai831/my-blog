(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{728:function(n,e,a){"use strict";a.r(e);var r=a(4),t=Object(r.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"_1、前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、前言"}},[n._v("#")]),n._v(" 1、前言")]),n._v(" "),a("p",[n._v("在我们conding中，我们都用过数组这个数据结构，我们除了使用了数组自带的增删改查方法，还会使用带数组身上各类的API方法，下面我就来介绍数组身上的各类api方法。")]),n._v(" "),a("h1",{attrs:{id:"_2、迭代属性的api方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、迭代属性的api方法"}},[n._v("#")]),n._v(" 2、迭代属性的API方法")]),n._v(" "),a("h2",{attrs:{id:"_2-1-array-every"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-array-every"}},[n._v("#")]),n._v(" 2.1 Array.every()")]),n._v(" "),a("h4",{attrs:{id:"_1-evrry-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-evrry-原理"}},[n._v("#")]),n._v(" 1. evrry()原理：")]),n._v(" "),a("p",[a("code",[n._v("every()")]),n._v(" 方法接受一个回调函数作为参数，它是检查数组中的所有元素是否都通过了我们的限制条件，"),a("code",[n._v("every()")]),n._v(" 方法对数组中存在的每个元素都会去执行一次：")]),n._v(" "),a("ul",[a("li",[n._v("如果找到函数返回 false 值的数组元素，"),a("code",[n._v("every()")]),n._v(" 返回 false，并且不检查剩余的元素")]),n._v(" "),a("li",[n._v("如果没有出现 false，"),a("code",[n._v("every()")]),n._v(" 返回 true")]),n._v(" "),a("li",[a("code",[n._v("every()")]),n._v(" 不改变原始数组")])]),n._v(" "),a("h4",{attrs:{id:"_2-evrry-方法的手写实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-evrry-方法的手写实现"}},[n._v("#")]),n._v(" 2. evrry()方法的手写实现：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const singer = [\n    { name: '111', num: 20 },\n    { name: '222', num: 25 },\n    { name: '333', num: 19 },\n    { name: '444', num: 10 },\n    { name: '555', num: 0 },\n  ]\n  Array.prototype.my_every = function(callback) {\n    for(let i = 0 ; i < this.length; i++) {\n     if(! callback(this[i],i,this) ){\n       return false\n     }\n    }\n    return true\n  }\n\n  const newSinger = singer.my_every((item, index, arr) => {\n    return item.num > 10  // singer[4].num < 10\n  })\n  console.log(newSinger); //false \n")])])]),a("h2",{attrs:{id:"_2-2-array-some"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-array-some"}},[n._v("#")]),n._v(" 2.2 Array.some()")]),n._v(" "),a("h3",{attrs:{id:"_1-some-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-some-原理"}},[n._v("#")]),n._v(" 1.some()原理")]),n._v(" "),a("p",[a("code",[n._v("some()")]),n._v(" 方法也接受一个回调函数作为参数，与"),a("code",[n._v("every()")]),n._v("相反，它是检查数组中的任何元素是否通过我们的限制条件，"),a("code",[n._v("some()")]),n._v(" 方法对数组中存在的每个元素执行一次函数：")]),n._v(" "),a("ul",[a("li",[n._v("如果找到函数返回真值的数组元素，some() 返回ture,并且不检查剩余的元素")]),n._v(" "),a("li",[n._v("否则返回 false")]),n._v(" "),a("li",[a("code",[n._v("some()")]),n._v(" 不改变原始数组。")])]),n._v(" "),a("h3",{attrs:{id:"_2-some-方法的手写实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-some-方法的手写实现"}},[n._v("#")]),n._v(" 2.some()方法的手写实现")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const singer = [\n    { name: '111', num: 20 },\n    { name: '222', num: 25 },\n    { name: '333', num: 19 },\n    { name: '444', num: 10 },\n    { name: '555', num: 0 },\n  ]\n  Array.prototype.my_some = function(callback) {\n    for (let i = 0; i < this.length; i++) {\n      if (callback(this[i], i, this)) {\n        return true\n      }\n    }\n    return false\n  }\n  const newSinger = singer.my_some((item, index, arr) => {\n    return item.num > 20  // singer[1].num > 20\n  })\n  console.log(newSinger); // true\n")])])]),a("h2",{attrs:{id:"_2-3-array-map"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-array-map"}},[n._v("#")]),n._v(" 2.3 Array.map()")]),n._v(" "),a("h3",{attrs:{id:"_1-map-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-map-原理"}},[n._v("#")]),n._v(" 1.map()原理")]),n._v(" "),a("p",[a("code",[n._v("map()")]),n._v("方法接收三个参数，分别为 "),a("code",[n._v("item")]),n._v("（值）、"),a("code",[n._v("index")]),n._v("（下标）、"),a("code",[n._v("arr")]),n._v("（原数组），它使用为每个数组元素调用函数的结果创建新数组， 且函数一定要有"),a("code",[n._v("return")]),n._v("，并不会改变原始数组。")]),n._v(" "),a("h3",{attrs:{id:"_2-map-方法的手写实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-map-方法的手写实现"}},[n._v("#")]),n._v(" 2.map()方法的手写实现")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const singer = [\n    { name: '111', num: 20 },\n    { name: '222', num: 25 },\n    { name: '333', num: 19 },\n    { name: '444', num: 10 },\n    { name: '555', num: 0 },\n  ]\n  Array.prototype.my_map = function(callback) {\n    const res = []\n    for (let i = 0; i < this.length; i++) {\n      res.push(callback(this[i], i, this))\n    }\n    return res\n  }\n\n  const newSinger = singer.my_map((item, index, arr) => {\n    return item.num > 20\n  })\n  console.log(newSinger); // [ false, true, false, false, false ]\n")])])]),a("h2",{attrs:{id:"_2-4-array-reduce"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-array-reduce"}},[n._v("#")]),n._v(" 2.4 Array.reduce()")]),n._v(" "),a("h3",{attrs:{id:"_1-reduce-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-reduce-原理"}},[n._v("#")]),n._v(" 1.reduce()原理")]),n._v(" "),a("p",[a("code",[n._v("reduce()")]),n._v(" 方法接受两个参数，第一个参数是一个回调函数，这个回调函数接受四个参数，分别为"),a("code",[n._v("pre")]),n._v("(上次函数的执行结果)、"),a("code",[n._v("next")]),n._v("(值)、"),a("code",[n._v("index")]),n._v("（下标）、"),a("code",[n._v("arr")]),n._v("（原数组），第二个参数为第一次执行回调函数时"),a("code",[n._v("pre")]),n._v("的初始值。")]),n._v(" "),a("p",[n._v("如果我们没有给第二个参数，则"),a("code",[n._v("pre")]),n._v("为数组的第一个值，"),a("code",[n._v("next")]),n._v("为数组的第二个值。"),a("code",[n._v("reduce()")]),n._v(" 方法也不会改变原始数组。一般我们会使用"),a("code",[n._v("reduce")]),n._v("方法实现数组的累加。")]),n._v(" "),a("h3",{attrs:{id:"_2-reduce-方法的手写实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-reduce-方法的手写实现"}},[n._v("#")]),n._v(" 2.reduce()方法的手写实现")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const singer = [\n    { name: '111', num: 20 },\n    { name: '222', num: 25 },\n    { name: '333', num: 19 },\n    { name: '444', num: 10 },\n    { name: '555', num: 1 },\n  ]\n  Array.prototype.my_reduce = function(callback, ...args) {\n    let pre, start = 0\n    if (args.length) {\n      pre = args[0]\n    } else {\n      pre = this[0]\n      start = 1\n    }\n    for (let i = start; i < this.length; i++) {\n      pre = callback(pre, this[i], i, this)\n    }\n    return pre\n  }\n  const newSinger = singer.my_reduce((pre, next, index, arr) => {\n    console.log(pre);//0 20 45 64 74\n    return pre + next.num\n  }, 0)\n\n  console.log(newSinger); // 75\n")])])]),a("h2",{attrs:{id:"_2-5-array-filter"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-array-filter"}},[n._v("#")]),n._v(" 2.5 Array.filter()")]),n._v(" "),a("h3",{attrs:{id:"_1-filter-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-filter-原理"}},[n._v("#")]),n._v(" 1.filter()原理")]),n._v(" "),a("p",[a("code",[n._v("filter()")]),n._v(" 方法接收三个参数，分别为"),a("code",[n._v("item")]),n._v("、"),a("code",[n._v("index")]),n._v("、"),a("code",[n._v("arr")]),n._v("，他创建了一个新的数组，其中填充了所有满足我们的限制条件的元素。"),a("code",[n._v("filter()")]),n._v("也不会改变原始数组。")]),n._v(" "),a("h3",{attrs:{id:"_2-filter-方法的手写实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-filter-方法的手写实现"}},[n._v("#")]),n._v(" 2.filter()方法的手写实现")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const singer = [\n    { name: '111', num: 20 },\n    { name: '222', num: 25 },\n    { name: '333', num: 19 },\n    { name: '444', num: 10 },\n    { name: '555', num: 0 },\n  ]\n  Array.prototype.my_filter = function(callback) {\n    const res = []\n    for (let i = 0; i < this.length; i++) {\n      callback(this[i], i, this) && res.push(this[i])\n    }\n    return res\n  }\n  const newSinger = singer.filter((item, index, arr) => {\n    return item.num > 15\n  })\n  console.log(newSinger); \n  // [\n  //   { name: '111', num: 20 },\n  //   { name: '222', num: 25 },\n  //   { name: '333', num: 19 }\n  // ]\n")])])]),a("h2",{attrs:{id:"_2-6-array-foreach"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-array-foreach"}},[n._v("#")]),n._v(" 2.6 Array.forEach()")]),n._v(" "),a("h3",{attrs:{id:"_1-foreach-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-foreach-原理"}},[n._v("#")]),n._v(" 1.forEach()原理")]),n._v(" "),a("p",[a("code",[n._v("forEach()")]),n._v(" 方法一个回调函数作为参数，"),a("code",[n._v("forEach()")]),n._v("方法按顺序为数组中的每个元素调用一次函数。")]),n._v(" "),a("h3",{attrs:{id:"_2-foreach-方法的手写实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-foreach-方法的手写实现"}},[n._v("#")]),n._v(" 2.forEach()方法的手写实现")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const singer = [\n  { name: '111', num: 20 },\n  { name: '222', num: 25 },\n  { name: '333', num: 19 },\n  { name: '444', num: 10 },\n  { name: '555', num: 0 },\n]\n  Array.prototype.my_forEach = function(callback) {\n    for (let i = 0; i < this.length; i++) {\n      callback(this[i], i, this)\n    }\n  }\n  singer.my_forEach((item, index, arr) => {\n    console.log(item, index);\n  })\n// { name: '111', num: 20 } 0\n// { name: '222', num: 25 } 1\n// { name: '333', num: 19 } 2\n// { name: '444', num: 10 } 3\n// { name: '555', num: 0 } 4\n")])])]),a("h1",{attrs:{id:"_3、查找属性的api方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、查找属性的api方法"}},[n._v("#")]),n._v(" 3、查找属性的API方法")]),n._v(" "),a("h2",{attrs:{id:"_3-1-array-find"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-array-find"}},[n._v("#")]),n._v(" 3.1 Array.find()")]),n._v(" "),a("h3",{attrs:{id:"_1-find-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-find-原理"}},[n._v("#")]),n._v(" 1.find()原理")]),n._v(" "),a("p",[a("code",[n._v("find()")]),n._v(" 方法接收三个参数，分别为 "),a("code",[n._v("val")]),n._v("（你要查找元素）、"),a("code",[n._v("start")]),n._v("（开始查找的位置）、"),a("code",[n._v("end")]),n._v("（结束的查找的位置）,它返回数组中"),a("strong",[n._v("第一个")]),n._v("通过限制的的元素的值。"),a("code",[n._v("find()")]),n._v(" 方法对数组中存在的每个元素执行一次函数：")]),n._v(" "),a("ul",[a("li",[n._v("如果找到函数返回 true 值的数组元素，则 find() 返回该数组元素的值（并且不检查剩余值）")]),n._v(" "),a("li",[n._v("否则返回 undefined")]),n._v(" "),a("li",[a("code",[n._v("find()")]),n._v(" 不会改变原始数组。")])]),n._v(" "),a("h3",{attrs:{id:"_2-find-方法的手写实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-find-方法的手写实现"}},[n._v("#")]),n._v(" 2.find()方法的手写实现")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const singer = [\n  { name: '111', num: 20 },\n  { name: '222', num: 25 },\n  { name: '333', num: 19 },\n  { name: '444', num: 10 },\n  { name: '555', num: 0 },\n]\n  Array.prototype.my_find = function(callback) {\n    for (let i = 0; i < this.length; i++) {\n      if (callback(this[i], i, this)) {\n        return this[i]\n      }\n    }\n    return undefined\n  }\n  const res = singer.my_find((item, index, arr) => {\n    return item.num > 20\n  })\n\n  console.log(res); // { name: '222', num: 25 }\n")])])]),a("h2",{attrs:{id:"_3-2-array-findindex"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-array-findindex"}},[n._v("#")]),n._v(" 3.2 Array.findIndex()")]),n._v(" "),a("h3",{attrs:{id:"_1-findindex-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-findindex-原理"}},[n._v("#")]),n._v(" 1.findIndex()原理")]),n._v(" "),a("p",[a("code",[n._v("findIndex()")]),n._v(" 方法与"),a("code",[n._v("find（）")]),n._v("方法原理相同，如果找到了返回对应"),a("strong",[n._v("下标值")]),n._v("，否则返回"),a("code",[n._v("-1")])]),n._v(" "),a("h3",{attrs:{id:"_2-findindex-方法的手写实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-findindex-方法的手写实现"}},[n._v("#")]),n._v(" 2.findIndex()方法的手写实现")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const singer = [\n    { name: '111', num: 20 },\n    { name: '222', num: 25 },\n    { name: '333', num: 19 },\n    { name: '444', num: 10 },\n    { name: '555', num: 0 },\n  ]\n  Array.prototype.my_findIndex = function(callback) {\n    for (let i = 0; i < this.length; i++) {\n      if (callback(this[i], i, this)) {\n        return i\n      }\n    }\n    return -1\n  }\n  const res = singer.findIndex((item, index, arr) => {\n    return item.num > 30\n  })\n  console.log(res); // -1\n")])])]),a("h1",{attrs:{id:"_4、其他的好用api方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、其他的好用api方法"}},[n._v("#")]),n._v(" 4、其他的好用API方法")]),n._v(" "),a("h2",{attrs:{id:"_4-1-array-include"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-array-include"}},[n._v("#")]),n._v(" 4.1 Array.include()")]),n._v(" "),a("h3",{attrs:{id:"_1-includes-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-includes-原理"}},[n._v("#")]),n._v(" 1.includes()原理")]),n._v(" "),a("p",[a("code",[n._v("includes()")]),n._v(" 方法接收两个参数，第一个参数为数组是否包含的元素，第二个参数为从数组某个位置开始向后查找，如果第二个个参数为负数，则从负数加上数组长度的位置开始。如果数组包含元素，则此方法返回 "),a("code",[n._v("true")]),n._v("，否则返回 "),a("code",[n._v("false")]),n._v("。且该方法区分大小写。")]),n._v(" "),a("p",[n._v("使用"),a("code",[n._v("includes()")]),n._v("方法时，我们要考虑当我们第一个参数为"),a("code",[n._v("NaN")]),n._v("时，由于"),a("code",[n._v("NaN != NaN")]),n._v("，所以在我们手写实现时，我们将这种情况考虑进去")]),n._v(" "),a("h3",{attrs:{id:"_2-includes-方法的手写实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-includes-方法的手写实现"}},[n._v("#")]),n._v(" 2.includes()方法的手写实现")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let obj = { name: '111', num: 25 }\nconst singer = [\n  { name: '222', num: 20 },\n  obj,\n  { name: '333', num: 19 },\n  { name: '444', num: 10 },\n  { name: '555', num: 0 },\n]\nconst nums = [1, 2, 3, 4, 5, NaN]\nArray.prototype.my_includes = function(val, start = 0) {\n  if (start < 0) start = this.length + start\n  const isNaN = Number.isNaN(val)\n  for (let i = start; i < this.length; i++) {\n    if (this[i] === val || (isNaN && Number.isNaN(this[i]))) { // NaN === NaN\n      return true\n    }\n  }\n  return false\n}\nconst res = nums.my_includes(NaN, 0)\nconsole.log(res); // true\n")])])]),a("h2",{attrs:{id:"_4-2-array-join"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-array-join"}},[n._v("#")]),n._v(" 4.2 Array.join()")]),n._v(" "),a("h3",{attrs:{id:"_1-join-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-join-原理"}},[n._v("#")]),n._v(" 1.join()原理")]),n._v(" "),a("p",[a("code",[n._v("join()")]),n._v(" 方法将数组作为字符串返回。元素将由指定的分隔符分隔。默认分隔符是逗号 "),a("code",[n._v(",")]),n._v("。"),a("code",[n._v("join()")]),n._v(" 方法不会改变原始数组。")]),n._v(" "),a("h3",{attrs:{id:"_2-join-方法的手写实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-join-方法的手写实现"}},[n._v("#")]),n._v(" 2.join()方法的手写实现")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const arr = [1, 2, 3, 4, 'hello']\nArray.prototype.my_join = function(s = ',') {\n  let str = ''\n  for (let i = 0; i < this.length; i++) {\n    if (i === this.length - 1) {\n      str += this[i]\n    } else {\n      str += this[i] + s\n    }\n    // str += i === this.length - 1 ? this[i] : this[i] + s // 简洁版\n  }\n  return str\n}\nconst str = arr.my_join()\nconsole.log(str);\n")])])]),a("h2",{attrs:{id:"_4-3-array-flat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-array-flat"}},[n._v("#")]),n._v(" 4.3 Array.flat()")]),n._v(" "),a("h3",{attrs:{id:"_1-flat-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-flat-原理"}},[n._v("#")]),n._v(" 1.flat()原理")]),n._v(" "),a("p",[a("code",[n._v("flat()")]),n._v("方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。其接收一个参数"),a("strong",[n._v("默认值为1")]),n._v("，表示需要深度遍历几次，超出数组维度则指挥遍历"),a("strong",[n._v("数组维度-1")]),n._v("次,使其成为以为数组")]),n._v(" "),a("h3",{attrs:{id:"_2-flat-方法的手写实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-flat-方法的手写实现"}},[n._v("#")]),n._v(" 2.flat()方法的手写实现")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const arr = [ 1, 2, [3, 4, [5]], 6, {a: 7} ]\nArray.prototype.myflat = function(num = 1) {\n  let newArr = this\n  let i = 0\n  while (newArr.some(item => Array.isArray(item)) && i < num) {\n    newArr = [].concat(...newArr) \n    i++\n  }\n  return newArr\n}\n\nconst newArr = arr.myflat(4)\n\nconsole.log(newArr); // [ 1, 2, 3, 4, 5, 6, { a: 7 } ]\n")])])]),a("h2",{attrs:{id:"_4-4-array-splice"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-array-splice"}},[n._v("#")]),n._v(" 4.4 Array.splice()")]),n._v(" "),a("h3",{attrs:{id:"_1-splice-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-splice-原理"}},[n._v("#")]),n._v(" 1.splice()原理")]),n._v(" "),a("p",[a("code",[n._v("splice()")]),n._v("方法可以接收任意个参数，它的第一个参数为切割数组的起始位置（start），第二个参数为我们需要切割的长度（length），而后面的参数则为我们需要添加到原数组上的值。splice会改变原来的数组。在我们手写"),a("code",[n._v("splice()")]),n._v("方法时，我们要注意以下几点：")]),n._v(" "),a("ol",[a("li",[n._v("splice方法是先切割数组，再向其添加我们的想要向原数组的值")]),n._v(" "),a("li",[n._v("splice方法会改变原数组，同时也会返回出一个新数组")]),n._v(" "),a("li",[n._v("当我们传进来的第一个参数为复数时，我们需要从（start+数组长度）的位置开始切割")]),n._v(" "),a("li",[n._v("当我们切割的长度大于原数组长度的最大值时，我们要改变新数组的长度，去除新数组后面的"),a("code",[n._v("undefined")]),n._v("值")])]),n._v(" "),a("h3",{attrs:{id:"_2-splice-方法的手写实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-splice-方法的手写实现"}},[n._v("#")]),n._v(" 2.splice()方法的手写实现")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const singer = [\n  { name: '111', num: 20 },\n  { name: '222', num: 25 },\n  { name: '333', num: 19 },\n  { name: '444', num: 10 },\n  { name: '555', num: 0 },\n]\n\nArray.prototype.my_splice = function (start, length, ...args) {\n  const result = [], targetArr = []; // 新数组 原数组\n   // 判断第一个参数是否小于零\n  if (start < 0) { \n    start = this.length + start\n  }\n// 生成新数组同时将原数组剩余的值和要添加的值给到 targetArr\n  for (let i = 0; i < this.length; i++) {\n    if (i === start) {\n      for (let j = start; j < start + length; j++) {\n        result.push(this[j]);\n        i = j;\n      }\n      targetArr.push(...args);\n      if (!length) { targetArr.push(this[i]); }\n    } else {\n      targetArr.push(this[i]);\n    }\n  }\n// 给原数组赋值\n  for (let i = 0; i < targetArr.length; i++) {\n    this[i] = targetArr[i]\n  }\n  // 去除新数组上的undefined\n  if (start + length > this.length) {\n    if (start === 0) {\n      result.length = this.length\n    } else {\n      result.length = this.length - 1 - start\n    }\n  }\n  this.length = targetArr.length\n  return result;\n\n}\nconst arr = singer.my_splice(-2, 10, 'hello', 'world', '123')\nconsole.log(singer);\n// [\n//   { name: '111', num: 20 },\n//   { name: '222', num: 25 },\n//   { name: '333', num: 19 },\n//   'hello',\n//   'world',\n//   'laoli'\n// ]\nconsole.log(arr);\n// [ { name: '444', num: 10 }, { name: '555', num: 0 } ]\n")])])]),a("h2",{attrs:{id:"_4-5-array-fill"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-array-fill"}},[n._v("#")]),n._v(" 4.5 Array.fill()")]),n._v(" "),a("h3",{attrs:{id:"_1-fill-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-fill-原理"}},[n._v("#")]),n._v(" 1.fill()原理")]),n._v(" "),a("p",[a("code",[n._v("fill()")]),n._v(" 方法接受三个参数，分别是分别为 "),a("code",[n._v("val")]),n._v("（你要填充元素）、"),a("code",[n._v("start")]),n._v("（开始查找的位置）、"),a("code",[n._v("end")]),n._v("（结束的查找的位置），它是向数组中填充指定的元素。可以指定开始和结束填充的位置。如果未指定，则将填充所有元素。"),a("code",[n._v("fill()")]),n._v(" 会覆盖原数组。要注意的一点是："),a("strong",[n._v("当我们填充一个引用类型的数据时，当我们改变了该引用类型的值时，数组的值也会改变")])]),n._v(" "),a("h3",{attrs:{id:"_2-fill-方法的手写实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-fill-方法的手写实现"}},[n._v("#")]),n._v(" 2.fill()方法的手写实现")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let obj = { name: '666', num: 12}\nlet singer = [\n  { name: '111', num: 20 },\n  { name: '222', num: 25 },\n  { name: '333', num: 19 },\n  { name: '444', num: 10 },\n  { name: '555', num: 0 },\n]\n  Array.prototype.my_fill = function(val, start = 0, end) {\n    end = end || this.length\n    for (let i = start; i < end; i++) {\n      this[i] = val\n    }\n    return this\n  }\n  singer.my_fill(obj, 0, 1)\n  console.log(singer[0]); //{ name: '666', num: 12 }\n\n  obj.num = 13\n  console.log(singer[0]); // { name: '666', num: 12 }\n")])])]),a("h1",{attrs:{id:"_5、结语"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、结语"}},[n._v("#")]),n._v(" 5、结语")]),n._v(" "),a("p",[n._v("学习阶段，欢迎指教，码字不易，点个赞呗。")])])}),[],!1,null,null,null);e.default=t.exports}}]);