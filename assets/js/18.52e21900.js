(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{730:function(o,e,v){"use strict";v.r(e);var _=v(4),t=Object(_.a)({},(function(){var o=this,e=o.$createElement,v=o._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[v("h1",{attrs:{id:"前言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[o._v("#")]),o._v(" 前言")]),o._v(" "),v("p",[o._v("在我们写"),v("code",[o._v("JavaScript")]),o._v("中的循环时，我们是不是只会用for和"),v("code",[o._v("while")]),o._v("？这时我就会想,有没有更优雅的写法可以发挥同样的作用呢？那今天我就来介绍两种不一样的循环写法吧！来分析分析 "),v("code",[o._v("for of")]),o._v(" 、"),v("code",[o._v("for in")]),o._v(" 与 "),v("code",[o._v("for")]),o._v("、"),v("code",[o._v("while")]),o._v(" 的区别吧！")]),o._v(" "),v("p",[o._v("在介绍这这两个循环前，我先来介绍一个概念吧：")]),o._v(" "),v("h2",{attrs:{id:"iterator-遍历器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#iterator-遍历器"}},[o._v("#")]),o._v(" Iterator（遍历器）")]),o._v(" "),v("p",[v("code",[o._v("Iterator")]),o._v("是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 "),v("code",[o._v("Iterator")]),o._v(" 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。")]),o._v(" "),v("p",[v("code",[o._v("Iterator")]),o._v(" 的作用有三个：一是为各种数据结构（"),v("code",[o._v("Objiect")]),o._v("、"),v("code",[o._v("Array")]),o._v("、"),v("code",[o._v("Set")]),o._v("、"),v("code",[o._v("Map")]),o._v("...），提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令"),v("code",[o._v("for...of")]),o._v("（"),v("code",[o._v("for...in")]),o._v("）循环，"),v("code",[o._v("Iterator")]),o._v(" 接口主要供"),v("code",[o._v("for...of")]),o._v("("),v("code",[o._v("for...in")]),o._v(")使用。")]),o._v(" "),v("p",[o._v("原生具备 Iterator 接口的数据结构如下所示：")]),o._v(" "),v("ul",[v("li",[o._v("Array")]),o._v(" "),v("li",[o._v("Map")]),o._v(" "),v("li",[o._v("Set")]),o._v(" "),v("li",[o._v("String")]),o._v(" "),v("li",[o._v("TypedArray")]),o._v(" "),v("li",[o._v("函数的 arguments 对象")]),o._v(" "),v("li",[o._v("NodeList 对象")])]),o._v(" "),v("h2",{attrs:{id:"for-in"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#for-in"}},[o._v("#")]),o._v(" for in")]),o._v(" "),v("p",[o._v("语法："),v("code",[o._v("for(let/const/var index in object){...}")])]),o._v(" "),v("p",[v("code",[o._v("index")]),o._v("：在每次迭代时，"),v("code",[o._v("index")]),o._v("会被赋值为不同的属性名；"),v("code",[o._v("object")]),o._v("：非 "),v("code",[o._v("Symbo")]),o._v(" 类型的可枚举属性被迭代的对象。")]),o._v(" "),v("h3",{attrs:{id:"使用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[o._v("#")]),o._v(" 使用场景：")]),o._v(" "),v("p",[o._v("1.遍历对象")]),o._v(" "),v("p",[v("code",[o._v("for in")]),o._v("在遍历对象时，原型上的属性也会被遍历下来，"),v("code",[o._v("for in")]),o._v("中的"),v("code",[o._v("i")]),o._v("表示的是对象的"),v("code",[o._v("key")]),o._v("，如果我们想遍历对象的值得时候，我们需要搭对象名来使用。")]),o._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[o._v("  const obj = {\n    a: 1,\n    b: 2,\n    c: 3\n}\nObject.prototype.d = 4\nfor(let i in obj ) {\n    console.log(i);\n}\n    // a b c d\n\nfor(let i in obj ) {\n    console.log(obj[i]);\n}\n    // 1 2 3 4 \n")])])]),v("p",[o._v("2.遍历数组/字符串")]),o._v(" "),v("p",[v("code",[o._v("for in")]),o._v(" 在遍历数组和字符串时，与遍历对象相同， 原型上的也属性也会被遍历下来，遍历的是数组或字符串的下标，如果想获得数组或字符串的值得话，也要带上数组或字符串名。")]),o._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[o._v("Array.prototype.c = 'c'\n\nconst arr = [1, 2, 3, 4]\nfor(let i in arr ) {\n    console.log(i);\n}\n    // 0 1 2 3 c\n    for(let i in arr ) {\n    console.log(arr[i]);\n}\n    // 1 2 3 4 c\nconst str = 'abc'\nfor(let i in str) {\n    console.log(i)\n}\n    // 0 1 2\nfor(let i in str) {\n    console.log(str[i])\n} \n    //  a b c\n")])])]),v("h2",{attrs:{id:"for-of"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#for-of"}},[o._v("#")]),o._v(" for of")]),o._v(" "),v("p",[o._v("语法："),v("code",[o._v("for(let/const/var value of object){...}")])]),o._v(" "),v("p",[v("code",[o._v("value")]),o._v("：在每次迭代中，将不同属性的值分配给变量。；"),v("code",[o._v("object")]),o._v("：被迭代枚举其属性的对象。")]),o._v(" "),v("h3",{attrs:{id:"使用场景-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用场景-2"}},[o._v("#")]),o._v(" 使用场景")]),o._v(" "),v("p",[o._v("1.遍历对象")]),o._v(" "),v("p",[v("code",[o._v("for of")]),o._v("不能遍历对象，因为对象没有"),v("code",[o._v("iterable")]),o._v("（遍历器）属性。")]),o._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[o._v("const obj = {\n    a: 1,\n    b: 2,\n    c: 3\n}\nObject.prototype.d = 4\nfor (let i of obj) {\n    console.log(i);\n}\n\n//  TypeError: obj is not iterable\n")])])]),v("p",[o._v("2.遍历数组/字符串")]),o._v(" "),v("p",[v("code",[o._v("for of")]),o._v(" 在遍历数组和字符串时， 原型上的属性是不会被遍历下来，"),v("code",[o._v("i")]),o._v(" 代表的数组或字符串。")]),o._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[o._v("Array.prototype.c = 'c'\n\nconst arr = [1, 2, 3, 4]\nfor(let i of arr ) {\n    console.log(i);\n}\n\n    // 1 2 3 4 \nconst str = 'abc'\nfor(let i of str) {\n    console.log(i)\n}\n    //   a b c\n\n")])])]),v("p",[o._v("3.遍历Set/Map数据结构")]),o._v(" "),v("p",[v("code",[o._v("for of")]),o._v(" 在遍历"),v("code",[o._v("Set")]),o._v("时，与遍历数组方法相同，但在遍历"),v("code",[o._v("Map")]),o._v("，只能将键和值一起遍历下来，如果指向遍历键或者得话，"),v("code",[o._v("i")]),o._v("要写成数组的形式。")]),o._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[o._v("const s = new Set([1, 2, 3, 4])\nfor(let i of s ) {\n    console.log(i);\n}\n    // 1 2 3 4\n    \n\nconst myMap=new Map();\nmyMap.set('1', '2');\nmyMap.set('3', '4');\nfor(let i of myMap) {\n    console.log(i);\n}\n\n    //  [ '1', '2' ]  [ '3', '4' ]\nfor (let [key, value] of myMap) {\n    console.log(key + value);\n\n}\n    // 12 34\n")])])]),v("h2",{attrs:{id:"区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[o._v("#")]),o._v(" 区别")]),o._v(" "),v("p",[o._v("1.使用 "),v("code",[o._v("for in")]),o._v(" 遍历，遍历的都是数据结构的下标（"),v("code",[o._v("index")]),o._v("）或者键（"),v("code",[o._v("key")]),o._v("），使用 "),v("code",[o._v("for of")]),o._v(" 遍历 遍历则是数据结构的值（"),v("code",[o._v("value")]),o._v("）。")]),o._v(" "),v("p",[o._v("2."),v("code",[o._v("for in")]),o._v(" 可以遍历所有的数据结构，但是"),v("code",[o._v("for of")]),o._v("只能遍历具有"),v("code",[o._v("Iterator")]),o._v("属性的数据结构，所以相对于"),v("code",[o._v("for in")]),o._v("，"),v("code",[o._v("for of")]),o._v("更加适用遍历数、数组对象、字符串、Map、Set等拥有迭代器对象的集合，也于for循环更相似，使用起来也更方便。")]),o._v(" "),v("p",[o._v("3."),v("code",[o._v("for in")]),o._v("会遍历到数据结构自身的和原型上的可枚举的属性和方法，但是"),v("code",[o._v("for of")]),o._v(" 只会遍历数据结构自身的值。")]),o._v(" "),v("p",[o._v("4."),v("code",[o._v("for in")]),o._v("遍历对象得到的属性值顺序与和原对象的属性值顺序不相同，因为"),v("code",[o._v("ECMAScript")]),o._v(" 规范中定义了数字属性应该按照索引值大小升序排列，字符串属性根据创建时的顺序升序排列。")]),o._v(" "),v("h1",{attrs:{id:"结语"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#结语"}},[o._v("#")]),o._v(" 结语")]),o._v(" "),v("p",[v("code",[o._v("for")]),o._v("、 "),v("code",[o._v("while")]),o._v("、"),v("code",[o._v("for in")]),o._v("、 "),v("code",[o._v("for of")]),o._v("这四种不同的方法，在不同的场景都各有千秋，只有我们灵活的掌握这些不同的方法，我们才可以更加合理的利用这些方法，才能使我们的代码更优雅。")])])}),[],!1,null,null,null);e.default=t.exports}}]);