(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{746:function(e,n,s){"use strict";s.r(n);var t=s(4),r=Object(t.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),s("p",[e._v("在我们面试前端开发工程师中，我们都逃不过的一个问题就是异步代码的解决方案。而在异步解决中，我们最常见的手段就是用"),s("code",[e._v("Promise")]),e._v("解决。但只会用"),s("code",[e._v("Promise")]),e._v("是远远不够的，我们还得更深层次的去了解"),s("code",[e._v("Promise")]),e._v("实现，下面我们就来实现一个手写简化版的"),s("code",[e._v("Promise")]),e._v("吧。")]),e._v(" "),s("h1",{attrs:{id:"第一步-搭建promise框架"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第一步-搭建promise框架"}},[e._v("#")]),e._v(" 第一步：搭建Promise框架")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("(function(window) {// 值执行函数\n    //在promise原型上挂载then方法\n    myPromise.prototype.then = function(onResolved, onRejected) {} \n    \n    function MyPromise(executor){ // 构建promise函数\n    \n    function resolve(value){} // promise内部的resolve函数\n    \n    function reject(value){}\n    \n    try{ \n    \n    executor(resolve, reject)  //参数为实参\n    \n    }catch(error){  // 如果promise内代码执行出错，将错误抛出\n    \n    reject(error)\n    \n    }\n  }\n  \n   window.myPromise = myPromise //将promise挂载到window全局对象上\n   \n})(window)\n")])])]),s("p",[e._v("首先我们要了解Promise函数中帮我们"),s("strong",[e._v("干了啥事")]),e._v("：")]),e._v(" "),s("ul",[s("li",[s("ol",[s("li",[e._v("有一个promise构造函数")])])]),e._v(" "),s("li",[s("ol",{attrs:{start:"2"}},[s("li",[e._v("可以在promise后可以接.then()函数")])])]),e._v(" "),s("li",[s("ol",{attrs:{start:"3"}},[s("li",[e._v("接收了一个有两个参数的回调函数")])])]),e._v(" "),s("li",[s("ol",{attrs:{start:"4"}},[s("li",[e._v("参数在promise中作为函数调用")])])])]),e._v(" "),s("p",[e._v("这就是promise帮我干的事情，所以我们也就根据它帮我们干的事，我们来搭建"),s("strong",[e._v("promise框架")]),e._v("。")]),e._v(" "),s("ul",[s("li",[s("ol",[s("li",[e._v("先写一个promise构造函数")])])]),e._v(" "),s("li",[s("ol",{attrs:{start:"2"}},[s("li",[e._v("在promise构造函数的原型上写.then()方法")])])]),e._v(" "),s("li",[s("ol",{attrs:{start:"3"}},[s("li",[e._v("在promise函数把传进来的参数作为函数调用掉，同时将我们在promise写的函数作为实参传进去给回调函数使用")])])]),e._v(" "),s("li",[s("ol",{attrs:{start:"4"}},[s("li",[e._v("在promise中定义这两个函数，供回调函数调用")])])])]),e._v(" "),s("h1",{attrs:{id:"第二步-明确promise状态的变更"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第二步-明确promise状态的变更"}},[e._v("#")]),e._v(" 第二步：明确Promise状态的变更")]),e._v(" "),s("p",[e._v("在我们使用Promise，我们需要知道的一个很重要的知识点就是，Promise现在是处于什么状态？首先我们要知道Promise有三种状态：")]),e._v(" "),s("ul",[s("li",[e._v("pending")]),e._v(" "),s("li",[e._v("resloved（fulfilled）")]),e._v(" "),s("li",[e._v("rejected")])]),e._v(" "),s("p",[e._v("接下来我们再来看看"),s("strong",[e._v("Promise状态的特点")]),e._v("：")]),e._v(" "),s("ol",[s("li",[s("p",[s("code",[e._v("Promise")]),e._v("对象的状态不受外界影响。"),s("code",[e._v("Promise")]),e._v("对象代表一个异步操作，有三种状态："),s("code",[e._v("pending")]),e._v("（进行中）、"),s("code",[e._v("fulfilled")]),e._v("（已成功）和"),s("code",[e._v("rejected")]),e._v("（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。")])]),e._v(" "),s("li",[s("p",[e._v("一旦状态改变，就不会再变，任何时候都可以得到这个结果。"),s("code",[e._v("Promise")]),e._v("对象的状态改变，只有两种可能：从"),s("code",[e._v("pending")]),e._v("变为"),s("code",[e._v("fulfilled")]),e._v("和从"),s("code",[e._v("pending")]),e._v("变为"),s("code",[e._v("rejected")]),e._v("。")])])]),e._v(" "),s("p",[e._v("在明确完Promise的状态后，我们也就明白了我们需要在"),s("code",[e._v("resolve")]),e._v("和"),s("code",[e._v("reject")]),e._v("函数中需要去改变"),s("code",[e._v("Promise")]),e._v("的状态。")]),e._v(" "),s("h1",{attrs:{id:"第三步-完善promise构造函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第三步-完善promise构造函数"}},[e._v("#")]),e._v(" 第三步：完善Promise构造函数")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function MyPromise(executor){ \n    let self = this \n    self.status = 'pending' //  Promise的状态\n    self.data = undefined  // resolve或reject函数调用传进来的值\n    self.callbacks = []  // 在Promise未改变时，存.then函数中未执行的函数\n    \n    function resolve(value){\n        if(self.status !== 'pending') { // 确定Promise未改变\n             return\n         }\n         self.status = 'resolved' // 改变Pormise的状态\n         self.data = value // 在resolve函数调用是将传进来的值存起来\n         // 执行待执行的callback函数\n         if(self.callbacks.length > 0) {\n             setTimeout(() => {\n                 self.callbacks.forEach(callbackObj => {\n                    callbackObj.onResolved(value) \n                  })\n             })\n         }\n    } \n    //原理同上\n    function reject(value){\n        if(self.status !== 'pending') {\n             return\n         }\n         self.status = 'resolved'\n         self.data = value\n         if(self.callbacks.length > 0) {\n             setTimeout(() => {\n                 self.callbacks.forEach(callbackObj => {\n                    callbackObj.onResolved(value)\n                  })\n             })\n         }\n    }\n    \n    try{ \n    \n    executor(resolve, reject) \n    \n    }catch(error){  //如果Promise内部出现错误，执行reject函数捕获错误并抛出。\n    \n    reject(error)\n    \n    }\n  }\n")])])]),s("p",[e._v("在"),s("code",[e._v("Promise")]),e._v("构造函数中，我们首先要在"),s("code",[e._v("Promise")]),e._v("函数上挂上"),s("code",[e._v("状态")]),e._v("、"),s("code",[e._v("盛放传递的实参值得容器")]),e._v("、"),s("code",[e._v("盛放未执行函数的数组容器")]),e._v("这三个属性。接下来我们就需要完善我们"),s("code",[e._v("resolve")]),e._v("和"),s("code",[e._v("reject")]),e._v("函数的逻辑了。")]),e._v(" "),s("ul",[s("li",[e._v("首先我们要通过判断"),s("code",[e._v("Promise")]),e._v("函数的状态来确定我们的"),s("code",[e._v("resolve")]),e._v("或"),s("code",[e._v("reject")]),e._v("函数是否执行。")]),e._v(" "),s("li",[e._v("如果执行的话我们就"),s("strong",[e._v("需要改变Promise的状态")]),e._v("了，同时将传进来的实参值存起来。方便then函数取用。")]),e._v(" "),s("li",[e._v("接下来我们就需要判断一下"),s("strong",[e._v("callbacks数组中还有没有因为Promise函数状态未改变而被挂起的函数")]),e._v("。我们需要将其执行掉。")]),e._v(" "),s("li",[e._v("最后将"),s("code",[e._v("resolve")]),e._v("和"),s("code",[e._v("reject")]),e._v("函数作为实参供回调函数里的参数调用。")])]),e._v(" "),s("h1",{attrs:{id:"第四步-完善then函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第四步-完善then函数"}},[e._v("#")]),e._v(" 第四步：完善then函数")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("//then函数接受两个回调函数作为参数\nmyPromise.prototype.then = function(onResolved, onRejected) { \n        // 把回调用对象包裹存在callbacks中\n        let self = this\n        if(self.status === 'pending') {\n            this.callbacks.push({\n                onResolved,\n                onRejected\n            })\n        }else if (self.status === 'resolved') {\n           setTimeout(() => {\n             onResolved(self.data)\n           });\n        }else{\n            setTimeout(() => {\n                onRejected(self.data)\n               });\n        }\n       })\n")])])]),s("p",[e._v("在then函数中，我们首要的任务就是判断"),s("strong",[e._v("Promise的状态")]),e._v("，来确定我们我们的回调函数该怎么执行。总共有三种情况：")]),e._v(" "),s("ul",[s("li",[e._v("1.如果状态为pending时，我们就要将then函数中的回调函数挂起。")]),e._v(" "),s("li",[e._v("2.如果状态为resolved时，我们就需要自己将onResolved回调函数执行掉")]),e._v(" "),s("li",[e._v("3.如果状态为rejected时，我们即执行onRejected回调函数")])]),e._v(" "),s("p",[e._v("这样封装完，我们就可以实现promise.then的效果吗？下面我们来看看效果：")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59410c171bb449c89b03a57e5d81561~tplv-k3u1fbpfcp-watermark.image?",alt:"屏幕截图(94).png"}})]),e._v(" "),s("p",[e._v("我们可以看到，我们成功的打印出了"),s("code",[e._v("onResolved 1")]),e._v(", 这也就说明我们写的"),s("code",[e._v("Promise")]),e._v("没有问题, 但我们封装成这样就够了吗？")]),e._v(" "),s("h1",{attrs:{id:"第五步-实现then函数后可以继续接then函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第五步-实现then函数后可以继续接then函数"}},[e._v("#")]),e._v(" 第五步：实现then函数后可以继续接then函数")]),e._v(" "),s("p",[e._v("当我们把Promise封装成这样显然是不够的，因为我们还没有实现在then函数后在接.then(), 所以我们还需要完善我们的then函数，让我们的then函数中也可以接.then()。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("myPromise.prototype.then = function(onResolved, onRejected) {\n        // 把回调用对象包裹存在callbacks中\n        let self = this\n       return new myPromise((resolve, reject) => {\n        if(self.status === 'pending') {\n            this.callbacks.push({\n                onResolved,\n                onRejected\n            })\n        }else if (self.status === 'resolved') {\n           setTimeout(() => {\n           const result =  onResolved(self.data)\n           if(result instanceof myPromise) { // 没有额外的return\n               result.then( // 为了将result的状态变更成resolved\n               (val) => {resolve(val)},\n               (err) => {reject(err)}\n               )\n           }else{\n            resolve(result)\n           }\n           });\n        }else{\n            setTimeout(() => {\n                onRejected(self.data)\n               });\n        }\n       })\n    }\n")])])]),s("p",[e._v("如果我们想在"),s("code",[e._v(".then后面在接.then")]),e._v("的话，首先我们就需要在我们"),s("code",[e._v("第一个then")]),e._v("中有返回值，这样我们才可以在我们"),s("code",[e._v("第二个.then")]),e._v("中拿到前面的值，所以第一件事，我们需要在我们的"),s("strong",[e._v("then函数中返回出一个Pormise对象")]),e._v("。\n接下来，我们就要去处理一下我们第一个.then中的回调函数，所以在我们的then函数中干了第二件事，"),s("strong",[e._v("声明了一个result承接.then中的返回值")]),e._v("，然后又在我们的then函数中干了第三件事，"),s("strong",[e._v("判断result的类型，如果result是一个Promise对象，我们就去把在去调用一次then函数，否则我们就直接执行resolve即可")]),e._v("。")]),e._v(" "),s("p",[e._v("接下来我们就来看看效果：")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc7f9d63d6544f8e82aa5f961adbdcae~tplv-k3u1fbpfcp-watermark.image?",alt:"屏幕截图(95).png"}})]),e._v(" "),s("p",[e._v("如上图，我们成功的打印出了 "),s("code",[e._v("ok res2")]),e._v("，也就说明，我们实现了在我们封装的Promise可以在后面接.then。")]),e._v(" "),s("h1",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),s("p",[e._v("写到这里，我们也就顺利的实现了"),s("code",[e._v("简化版Promise")]),e._v("的封装，也实现其主要功能，虽然我们没有封装的Promise没有官方版那么强大，但是我们可以清晰的看到"),s("code",[e._v("Promise")]),e._v("的原理")]),e._v(" "),s("h1",{attrs:{id:"补充-完整代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#补充-完整代码"}},[e._v("#")]),e._v(" 补充（完整代码）")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("(function(window) {\n    myPromise.prototype.then = function(onResolved, onRejected) {\n\n        let self = this\n       return new myPromise((resolve, reject) => {\n        if(self.status === 'pending') {\n            this.callbacks.push({\n                onResolved,\n                onRejected\n            })\n        }else if (self.status === 'resolved') {\n           setTimeout(() => {\n           const result =  onResolved(self.data)\n           if(result instanceof myPromise) { // 没有额外的return\n               result.then( // 为了将result的状态变更成resolved\n               (val) => {resolve(val)},\n               (err) => {reject(err)}\n               )\n           }else{\n            resolve(result)\n           }\n           });\n        }else{\n            setTimeout(() => {\n                onRejected(self.data)\n               });\n        }\n       })\n    }\n    function myPromise(executor) {\n        let self = this\n        self.status = 'pending'\n        self.data = undefined\n        self.callbacks = []\n        function resolve(value) {\n            if(self.status !== 'pending') {\n                return\n            }\n            self.status = 'resolved'\n            self.data = value\n            if(self.callbacks.length > 0) {\n                setTimeout(() => {\n                    self.callbacks.forEach(callbackObj => {\n                        callbackObj.onResolved(value)\n                    })\n                })\n             }\n        }\n        function reject(value) {\n             if(self.status !== 'pending') {\n                return\n            }\n            self.status = 'reject'\n            self.data = value\n            if(self.callbacks.length > 0) {\n                setTimeout(() => {\n                    self.callbacks.forEach(callbackObj => {\n                        callbackObj.onRejected(value)\n                    })\n                })\n            }\n        }\n        try {\n            executor(resolve, reject)\n        } catch (error) {\n            reject(error)\n        }\n    }\n    window.myPromise = myPromise\n})(window)\n\n")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);